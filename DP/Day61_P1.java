/*
 You are the lead engineer in a high-tech robot factory with 'n production units', 
each assigned a number from 0 to n - 1. Every unit contains a specialized 
'robot component', and the efficiency level of each component is represented by 
an array components, where components[i] is the efficiency level of the i-th component.

As part of the factory shutdown protocol, you need to deactivate all the units 
one by one. However, the deactivation process is tricky — when you shut down the 
i-th unit, it triggers a chain reaction with its neighboring units, generating:

    components[i - 1] * components[i] * components[i + 1] power units

If i - 1 or i + 1 falls outside the range of the array, assume there’s a dummy 
component with efficiency level 1 installed for safety compliance.

Your objective is to maximize the total power generated by planning the shutdown
order strategically.

Example 1:
Input=
2 1 3 5
output=
51

Explanation:
Shutdown order:
[2,1,3,5] → [2,3,5] → [2,5] → [5] → []
Power generated:
2*1*3 + 2*3*5 + 1*2*5 + 1*5*1 = 51


Example 2:
Input= 
8 9
Output=
81

Explanation:
Deactivate both units in any order: 1*8*9 + 1*9*1 = 81

Constraints:

-> n == components.length
-> 1 <= n <= 300
-> 0 <= components[i] <= 100

 */
import java.util.*;
class Day61_P1{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        String[] s = sc.nextLine().split(" ");
        
        int[] arr = new int[s.length];
        for(int i=0;i<s.length;i++){
            arr[i] = Integer.parseInt(s[i]);
        }
        int n = arr.length;
        int[] nums = new int[arr.length+2];
        nums[0] = 1;
        nums[arr.length+1] = 1;
        for(int i=1;i<=arr.length;i++){
            nums[i] = arr[i - 1];
        }
        
        int[][] dp = new int[n+2][n+2];
        for(int[] row: dp){
            Arrays.fill(row, -1);
        }
        
        System.out.println(maxPower(0,arr.length+1,dp,nums));
        sc.close();
    }
    
    private static int maxPower(int l, int r,int[][] dp,int[] nums){
        if(l + 1 == r){
            return 0;
        }
        
        if(dp[l][r] != -1){
            return dp[l][r];
        }
        int maxp = 0;
        for(int i = l + 1;i < r;i++){
            int power = nums[l] * nums[i] * nums[r];
            int left = maxPower(l,i,dp,nums);
            int right = maxPower(i,r,dp,nums);
            maxp = Math.max(maxp, left + power + right);
        }
        
        return dp[l][r] = maxp;
        
        
    }
}
